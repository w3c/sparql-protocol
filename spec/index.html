<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8" />
    <title>SPARQL 1.2 Protocol</title>

    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
    <script src="./common/local-biblio.js" class="remove"></script>
    <script src="./common/fixup.js" class="remove"></script>

    <script class="remove">
      // All config options at https://respec.org/docs/
      var respecConfig = {
        group:                "rdf-star" ,
        localBiblio:          localBibliography,
        specStatus:           "ED",
        edDraftURI:           "https://w3c.github.io/sparql-protocol/spec/",
        testSuiteURI:         "https://w3c.github.io/rdf-tests/",
        shortName:            "sparql12-protocol",
        copyrightStart:       "2008",
         
        github:               "https://github.com/w3c/sparql-protocol",
        wgPublicList:         "public-rdf-star-wg",

//        implementationReportURI: "https://w3c.github.io/sparql12-protocol/reports/",
//        errata:               "https://w3c.github.io/sparql12-protocol/errata/",

        previousPublishDate:  "2013-03-21",
        prevRecURI:           "https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321",
        prevRecShortname:     "sparql11-protocol",
        previousMaturity:     "REC",
        
        editors: [ 
          { name: "Andy Seaborne", w3cid: "29909"},
          { name: "Ruben Taelman", w3cid: "84199"},
          { name: "Gregory Williams", w3cid: "38870"},
          { name: "Thomas Pellissier Tanon", w3cid: "73758"},
        ],
        formerEditors: [
          { name: "Lee Feigenbaum" },
          { name: "Gregory Todd Williams" },
          { name: "Kendall Grant Clark" },
          { name: "Elias Torres" },
        ],

        //doJsonLd:     true,
        
        lint: { "no-unused-dfns": false }
      };
    </script>

    <style>
      /* @import url("local.css"); */
      /* Inlined to make preview work */

/* CSS For SPARQL Query */

/* In-progress working draft artifacts - to be removed eventually */
  .issue	{ background-color: #fdd;
                  font-size: 88% ; }
  .add		{ background-color: #7fff7f }
  .remove	{ background-color: #ff7f7f }
ul.issue	{}
  .issueBlock	{ margin: 1em 4em 1em 2.5em ; /* Top Right Bottom Left */
                  padding: 1ex;
	          /*overflow: auto;*/
                  page-break-inside: avoid ; }
  .issueTopic	{ font-weight: bold ; }

 .todo		{ font-size: 80% ; color: #444 ; }
p.todo		{}

.wgNote	{ border: 0.2em solid red;
      padding: 0.5em ;
      margin: 1em 4em 1em 2em ; }

.box     { border: thin solid #888888;
           page-break-inside: avoid ;
           background-color: #F8F8F8 ; padding:1em ;
           margin-left:0 ; margin-right: 2ex; 
           margin-top: 0.1ex ; margin-bottom: 0.1ex ;
         }

/* Misc WD stuff */
span.cvs-id     {color: gray; font-size:80%; display: block; }

/* == General Tag Treatment == */
pre		 { margin: 1em 1em 1em 2.5em ; /* Top Right Bottom Left */
                   padding: 1ex;
	           /*overflow: auto;*/
                   page-break-inside: avoid ; }

/* Tables */
table, td	{ text-align: left; }
td, th   { border-style: solid;
                  border-width: 1px;
                  border-color: black;
                  border-bottom-color: gray;
                  border-right-color: gray; }
td.annotation, th.annotation { border-style: none; border-bottom-style: dotted; }
table.plain	{ border-spacing: 0px; padding: 0px ; border-collapse: collapse ; }
                  /* cellpadding="0" cellspacing="1" style="border-collapse: collapse */


th.major	{ background-color: #005a9c;
                  color: white; }
.subHeading	{ text-align: left;
                  background-color: #CCCCCC; }
th, td		{ padding: 3px; }
td		{ font-size: 85%; }
th a:link	{ text-decoration: none; }
th a:hover	{ background-color:#FFFF99;
                  text-decoration: underline; }

/* == Prototypes == */
pre.prototype	{ background-color:#f7f8ff;
                  border:thin solid #8888aa;
                  margin: 1em 1em 1em 0em ; }
.return, .type	{ color: #177 }

/* == Notes ==  */
.note		{ margin-left: 2.5em; margin-right: 4ex ; font-size: 85% ; font-style: italic ; }

/* Definitions */
.defn		{ margin-left:0 ; margin-right: 2ex; 
                  margin-top: 0.1ex ; margin-bottom: 0.1ex ;
                  /*border: double 1px #888888; *//* Buggy */
                  border: thin solid #888888;
                  padding: 1ex 2ex 0.5ex 2ex ; /* top, right, bottom, left */
                  page-break-inside: avoid ;
                  background-color: #F0F8F8 ; }
div.defn p	{ margin-top: 1ex ; margin-bottom: 1.5ex ;}
div.defn ul	{ margin-top: 1ex ; margin-bottom: 1.5ex ; }
@media print	{ .defn { margin: 1em 1em 1em 1em ; } }
span.definedTerm	{font-weight: bold;}

div.grammarExtract
                { border: thin solid #888888;
                  padding: 1ex 2ex 1ex 2ex ; /* top, right, bottom, left */
                  margin: 1em 6em 1em 2em ; 
                  page-break-inside: avoid ;
                  background-color: #F8F8F8 ; }

pre.codeBlock  { font-family:monospace ; page-break-inside: avoid ; 
                 margin: 0 ;
	         margin-right: 2ex ;
                 border: thin solid #888888; }




/* Examples */
pre.data	{ border: thin solid #88AA88;
                  background-color: #E8F0E8;
                  margin: 1em 1em 1em 0em ; }

pre.dataExcerpt	{ border: thin solid #88AA88;
                  background-color: #E8F0E8;
                  margin: 1em 1em 1em 0em ; }
/* Example Queries */
.query          { background-color:#f7f8ff; }
.queryExcerpt   { background-color:#f7f8ff; }
pre.query	{ border:thin solid #8888aa;
                  margin: 1em 1em 1em 0em ; }
/* Example Results */
.result		{ border: thin solid  #888888 ;
                  background-color: #F0F0F0 ; }
pre.resultGraph	{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }
pre.resultSet	{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }
pre.resultAsk	{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }
pre.resultTurtle{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }

pre.result	{ margin: 1em 4em 1em 0em ; }

div.result	{ font-family: monospace;
                  margin:  1em 4em 1em 0em ;
                  padding: 1ex ; }

.result table	{ border-collapse: collapse; }
.result table td{ border-width: 1px ;
                  border-color : black ; 
                  font-family: monospace ;
                  empty-cells: show;
                  padding-left: 1ex ; padding-right: 1ex ;
                  vertical-align:top;
                  text-align: left ; } 
/*  spacing: 0 ;*/
.result table th{ border-width: 1px ;
                  font-family: monospace ;
                  border-color: black ;
                  empty-cells: show;
                  padding-left: 1ex ; padding-right: 1ex ;
                  vertical-align:top;
                  text-align:center; } 

/* Examples : Algebra */
div.algExample {  border: thin solid #888888;
                  page-break-inside: avoid ;
                  padding:0.5em ; margin:0.5em ;
                  margin-left: 2em ; margin-right: 2em ;
                  font-family:monospace ; }

div.algExample1 { padding:0.5em ; background-color: #F0F0FF ; }
div.algExample2 { padding:0.5em ; margin-top: 0.5em ; background-color: #F0FFF0 ; }

/* Grammar Mark-up */
.operator	{ color: #3f3f5f;
                  text-transform: uppercase; }
.function	{ color: #3f3f5f;
                }

/* Tuned to cope with different browsers behaviours */
div.grammarTable table	{ border-style: solid ;
			  border-width: 1px ;
			  border-color: #AAA ;
			  border-spacing: 0px ; 
			  border-collapse: collapse ; }

div.grammarTable table * { border-left-width: 0px ;
			   border-right-width: 0px ;
			   border-color: #AAA ; } 

div.grammarTable table * tr   { border-top-style: solid ;
			  border-top-width: 1px ;
			  border-top-color: #AAA ; } 

.grammar	{ text-align: left ;
                  vertical-align: top ; }
.token		{ color: #3f3f5f; }
table.FAndOTable .token		{ color: #00c; }
table.FAndOTable .token:visited		{ color: #a0c; }
.gRuleHead	{ font-style: italic ;
                  font-family: monospace ; }
.gRuleBody	{ font-family: monospace ; }
.gRuleLabel	{ font-family: monospace ; }

.code		{ font-family: monospace; font-size: 100%; }
pre.code	{ font-family: monospace; font-size: 100%; margin: 0 ; }

/* Table of Contents */
.toc		{ text-indent: 0; }
DIV.toc UL UL, DIV.toc OL OL {margin-left: 0}
DIV.toc UL UL UL, DIV.toc OL OL OL {margin-left: 1em}
DIV.toc UL UL UL UL, DIV.toc OL OL OL OL {margin-left: 0}
LI.tocline1	{ font-weight: bold}
LI.tocline2	{ font-weight: normal}
LI.tocline4	{ font-style: italic}
/* The border in the following rule crashes NN4 on fonts.html :-(
DIV.subtoc	{ padding: 1em; border: solid black thin; margin: 1em 0;
                  background: #ddd} */
DIV.toc, UL.index, DT { text-align: left; }


/* References to the Rdf Data Model */
span.rdfDM	{ color: #11d; }


/* Truth Table */
  .truth	{ font-family: monospace; }
  .error	{ color: #ff1f1f; }
  table.truthTable td	{ text-align: center; font-family: monospace; }
  table.truthTable th	{ background-color: #dfdfdf; }
  table.truthTable tbody th	{ font-weight: normal; font-family: monospace; }

/* Casting table */
table.casting	{ font-size: x-small; }

.castY	{ background-color: #7FFF7F;
                  color: black; }

.castN	{ background-color: #FF7F7F;
                  color: black; }

.castM	{ background-color: white;
                  color: black; }

span.cancast:hover { background-color: #ffa;
                     color: black; }

.SPARQLoperator	{ background-color: #FFFFbf; /* yellow */
          }

.owlnonterminal {
    font-weight: bold;
    font-family: sans-serif;
    font-size: 95%;
}
.owlgrammar {
    margin-top: 1ex;
    margin-bottom: 1ex;
    padding-left: 1ex;
    padding-right: 1ex;
    padding-top: 1ex;
    padding-bottom: 0.6ex;
    border: 1px dashed #2f6fab;
    font-family: monospace;
}

      /* ReSpec */
      dfn { font-style: normal ; }
      /* ReSpec */

  code           { font-family: monospace; }

  div.constraint,
  div.issue,
  div.note,
  div.notice     { margin-left: 2em; }

  ol.enumar      { list-style-type: decimal; }
  ol.enumla      { list-style-type: lower-alpha; }
  ol.enumlr      { list-style-type: lower-roman; }
  ol.enumua      { list-style-type: upper-alpha; }
  ol.enumur      { list-style-type: upper-roman; }


  div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
  div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
  div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
  div.exampleWrapper { margin: 4px }
  div.exampleHeader { font-weight: bold;
                    margin: 4px}

  em.rfc2119 { text-transform: lowercase;
             font-variant: small-caps;
             font-style: normal; }
   @media (max-width: 850px) {
        table th, table td { font-size: 12px; padding: 3px 4px;}
    }
  @media (max-width: 767px) {
     table { word-break: normal; overflow-wrap: anywhere; }
     table tbody tr td:nth-child(4n), table tbody tr th:nth-child(4n) {max-width: 105px; overflow-wrap: anywhere; min-width: 90px;}
  }
    </style>
  </head>
  <body>
    <section id="abstract">
      <h2>Abstract</h2>
<p>The SPARQL Protocol and RDF Query Language (<span title="SPARQL Protocol And RDF Query Language">SPARQL</span>) is a query language and protocol for <a href=
    "http://www.w3.org/RDF/">RDF</a>. This document specifies the SPARQL Protocol; it describes a means for conveying SPARQL queries and updates to a SPARQL processing service and returning the
    results via HTTP to the entity that requested them. This protocol was developed by the <a href="http://www.w3.org/2009/sparql/wiki/Main_Page">W3C SPARQL Working Group</a>, part of the <a href=
    "http://www.w3.org/2001/sw/">Semantic Web Activity</a> as described in the <a href="http://www.w3.org/2001/sw/Activity">activity statement</a> .</p>
    </section>

    <section id="sotd" class="introductory">
      <p>
        This specification is published by the
        <a href="https://www.w3.org/groups/wg/rdf-star">RDF Star Working Group</a> as part of the
        update of specifications for format and errata.
      </p>
    </section>

    <section id="related" data-include="./common/sparql-related.html"></section>

<!-- BODY -->
    <section id="intro">
      <h2>Introduction</h2>
      <p>This document describes the SPARQL 1.2 Protocol, a means of conveying SPARQL queries and updates from clients to SPARQL processors. The SPARQL Protocol has been designed for compatibility
      with the [[[SPARQL12-QUERY]]] and with the [[[SPARQL12-UPDATE]]]. This document is primarily intended for software developers interested in implementing SPARQL query and update services and clients.</p>
      <p>The SPARQL Protocol consists of two HTTP operations: a <a href="#query-operation">query operation</a> for performing SPARQL Query Language queries and an <a href="#update-operation">update
      operation</a> for performing SPARQL Update Language requests. SPARQL Protocol clients send HTTP requests to SPARQL Protocol services that handle the request and send HTTP responses back to the
      originating client.</p>
      <p>A separate document describes the [[[SPARQL12-GRAPH-STORE-PROTOCOL]]] which describes the use of HTTP operations for the purpose
      of managing a collection of graphs in the REST architectural style.</p>
      <section id="conventions">
        <h3>Document Conventions</h3>
        <p>When this document uses the words <strong>must</strong>, <strong>must not</strong>, <strong>should</strong>, <strong>should not</strong>, <strong>may</strong> and
        <strong>recommended</strong>, and the words appear as emphasized text, they must be interpreted as described in <a data-cite="rfc2119#">RFC 2119</a>.</p>
      </section>
      <section id="terminology">
        <h3>Terminology</h3>
        <dl>
          <dt>SPARQL Protocol client</dt>
          <dd>An HTTP client (as defined by
            <a data-cite="rfc9110#connections">Section 3.3. Connections, Clients, and
            Servers</a> of [[[RFC9110]]] [[RFC9110]]) that sends HTTP requests for
            SPARQL Protocol operations. (Also known as: <em>client</em>.)</dd>

          <dd>An HTTP client (as defined by <a data-cite="rfc9110#connections">RFC 9110</a> [[RFC9110]]) that sends HTTP requests for SPARQL
          Protocol operations. (Also known as: <em>client</em>)</dd>
          <dt>SPARQL Protocol service</dt>
          <dd>An HTTP server that services HTTP requests and sends back HTTP responses for SPARQL Protocol operations. The URI at which a SPARQL Protocol service listens for requests is generally
          known as a SPARQL endpoint. (Also known as: <em>service</em>)</dd>
          <dt>SPARQL endpoint</dt>
          <dd>The URI at which a SPARQL Protocol service listens for requests from SPARQL Protocol clients.</dd>
          <dt>SPARQL Protocol operation</dt>
          <dd>An HTTP request and response that conform to the protocol defined in this document.</dd>
          <dt>RDF Dataset</dt>
          <dd>A collection of a default graph and zero or more named graphs, as defined by the <a data-cite="SPARQL12-QUERY#rdfDataset">SPARQL 1.2 Query Language</a>.</dd>
        </dl>
      </section>
    </section>
    <section id="protocol">
      <h2>SPARQL Protocol Operations</h2>
      <p>The SPARQL Protocol consists of two operations: query and update. A protocol operation defines combinations of:</p>
      <ul>
        <li>The HTTP method by which the request is sent.</li>
        <li>The HTTP query string parameters included in the HTTP request URI.</li>
        <li>The message content included in the HTTP request body.</li>
        <li>The message content included in the HTTP response body.</li>
      </ul>
      <p>The SPARQL 1.2 Protocol is built on top of HTTP. All HTTP requirements for requests and responses <strong>must</strong> be followed.</p>
      <section id="query-operation">
        <h3>Query Operation</h3>
        <p>The <code>query</code> operation is used to send a SPARQL query to a service and receive the results of the query. The query operation <strong>MUST</strong> be invoked with either the HTTP
        GET or HTTP POST method. Client requests for this operation <strong>must</strong> include exactly one SPARQL query string (parameter name: <code>query</code>) and <strong>may</strong> include
        zero or more default graph URIs (parameter name: <code>default-graph-uri</code>) and named graph URIs (parameter name: <code>named-graph-uri</code>). The response to a query request is either
        the [[[SPARQL12-RESULTS-XML]]], the [[[SPARQL12-RESULTS-JSON]]], the [[[SPARQL12-RESULTS-CSV-TSV]]], or an RDF serialization, depending on the <a data-cite="SPARQL12-QUERY#QueryForms">query
        form</a> and <a data-cite="rfc9110#content.negotiation">content negotiation</a> [[RFC9110]].
        </p>
        <span class="doc-ref" id="query-summary"></span>
        <table style="margin-left: auto; margin-right: auto; border-color: rgb(0, 0, 0); border-collapse: collapse; padding: 5px; border: 1px">
          <tbody>
            <tr>
              <th>&nbsp;</th>
              <th>HTTP Method</th>
              <th>Query String Parameters</th>
              <th>Request Content Type</th>
              <th>Request Message Body</th>
            </tr>
            <tr>
              <th>query via GET</th>
              <td>GET</td>
              <td><code>query</code> (exactly 1)<br>
              <code>default-graph-uri</code> (0 or more)<br>
              <code>named-graph-uri</code> (0 or more)</td>
              <td>None</td>
              <td>None</td>
            </tr>
            <tr>
              <th>query via URL-encoded POST</th>
              <td>POST</td>
              <td>None</td>
              <td><code>application/x-www-form-urlencoded</code></td>
              <td>URL-encoded, ampersand-separated query parameters.<br>
              <code>query</code> (exactly 1)<br>
              <code>default-graph-uri</code> (0 or more)<br>
              <code>named-graph-uri</code> (0 or more)</td>
            </tr>
            <tr>
              <th>query via POST directly</th>
              <td>POST</td>
              <td><code>default-graph-uri</code> (0 or more)<br>
              <code>named-graph-uri</code> (0 or more)</td>
              <td><code>application/sparql-query</code></td>
              <td>Unencoded SPARQL query string</td>
            </tr>
          </tbody>
        </table>
        <p>The <code>query</code> request's parameters <strong>must</strong> be sent according to one of these three options:</p>
        <section id="query-via-get">
          <h4><code>query</code> via GET</h4>
          <p>Protocol clients <strong>may</strong> send protocol requests via the HTTP GET method. When using the GET method, clients <strong>must</strong> URL <a data-cite="rfc3986#section-2.1">percent encode</a> 
          all parameters and include them as <a data-cite="rfc3986#section-3.4">query parameter</a> strings [[RFC3986]] with the names given
          above.</p>
          <p>HTTP query string parameters <strong>must</strong> be separated with the ampersand (<code>&amp;</code>) character. Clients may include the query string parameters in any order.</p>
          <p>The HTTP request <strong>MUST NOT</strong> include a message body.</p>
        </section>
        <section id="query-via-post-urlencoded">
          <h4><code>query</code> via POST with URL-encoded parameters</h4>
          <p>Protocol clients <strong>may</strong> send protocol requests via the HTTP POST method by URL encoding the parameters. When using this method, clients <strong>must</strong> URL 
          <a data-cite="rfc3986#section-2.1">percent encode</a> [[RFC3986]] all parameters and include them as parameters within the request body via the
          <code>application/x-www-form-urlencoded</code> media type with the name given above. Parameters <strong>must</strong> be separated with the ampersand (<code>&amp;</code>) character. Clients
          may include the parameters in any order. The content type header of the HTTP request <strong>must</strong> be set to <code>application/x-www-form-urlencoded</code>.</p>
        </section>
        <section id="query-via-post-direct">
          <h4><code>query</code> via POST directly</h4>
          <p>Protocol clients <strong>may</strong> send protocol requests via the HTTP POST method by including the query directly and unencoded as the HTTP request message body. When using this
          approach, clients <strong>must</strong> include the SPARQL query string, unencoded, and nothing else as the message body of the request. Clients <strong>must</strong> set the content type
          header of the HTTP request to <code>application/sparql-query</code>. Clients <strong>may</strong> include the optional <code>default-graph-uri</code> and <code>named-graph-uri</code>
          parameters as HTTP query string parameters in the request URI. Note that UTF-8 is the only valid charset here.</p>
        </section>
        <section id="dataset">
          <h4>Specifying an RDF Dataset</h4>
          <p>A SPARQL query is executed against an <a data-cite="SPARQL12-QUERY#rdfDataset">RDF Dataset</a>. The RDF Dataset for a query may be specified either via the
          <code>default-graph-uri</code> and <code>named-graph-uri</code> parameters in the SPARQL Protocol or in the SPARQL query string using the <code>FROM</code> and <code>FROM NAMED</code>
          keywords. If different RDF Datasets are specified in both the protocol request and the SPARQL query string, then the SPARQL service <strong>must</strong> execute the query using the RDF
          Dataset given in the protocol request.</p>
          <p>Note that a service <strong>may</strong> reject a query with HTTP response code 400 if the service does not allow protocol clients to specify the RDF Dataset.</p>
          <p>If an RDF Dataset is not specified in either the protocol request or the SPARQL query string, then implementations <strong>may</strong> execute the query against an
          implementation-defined default RDF dataset.</p>
        </section>
        <section id="conneg">
          <h4>Accepted Response Formats</h4>
          <p>Protocol clients <strong>should</strong> use HTTP <a data-cite="rfc9110#content.negotiation">content negotiation</a> [[RFC9110]] to request
          response formats that the client can consume. See below for more on potential response formats.</p>
        </section>
        <section id="query-success">
          <h4>Success Responses</h4>
          <p>The SPARQL Protocol uses the response status codes defined in HTTP to indicate the success or failure of an operation. Consult the <a data-cite="rfc9110#status.codes">HTTP specification</a> 
          [[RFC9110]] for detailed definitions of each status code. While a protocol service
          <strong>should</strong> use a 2XX HTTP response code for a successful query, it <strong>may</strong> choose instead to use a 3XX response code as per HTTP.</p>
          <p>The response body of a successful query operation with a 2XX response is either:</p>
          <ul>
            <li>a SPARQL Results Document in <a data-cite="SPARQL12-RESULTS-XML#">XML</a> [[SPARQL12-RESULTS-XML]], <a data-cite="SPARQL12-RESULTS-JSON#">JSON</a> [[SPARQL12-RESULTS-JSON]], or 
            <a data-cite="SPARQL12-RESULTS-CSV-TSV#">CSV/TSV</a> [[SPARQL12-RESULTS-CSV-TSV]] format (for SPARQL Query forms <a data-cite="SPARQL12-QUERY#select">SELECT</a> and <a data-cite=
            "SPARQL12-QUERY#ask">ASK</a> [[SPARQL12-QUERY]]); or,</li>
            <li>an RDF graph [[[RDF12-CONCEPTS]]] serialized, for example, in the [[[RDF12-XML]]], or an equivalent RDF graph serialization, for SPARQL Query forms <a data-cite="SPARQL12-QUERY#describe">DESCRIBE</a> 
            and <a data-cite="SPARQL12-QUERY#construct">CONSTRUCT</a> [[SPARQL12-QUERY]]).</li>
          </ul>
          <p>The content type of the response to a successful query operation must be the media type defined for the format of the response body.</p>
        </section>
        <section id="query-failure">
          <h4>Failure Responses</h4>
          <p>The HTTP response codes applicable to an unsuccessful query operation include:</p>
          <ul>
            <li>400 if the SPARQL query supplied in the request is not a legal sequence of characters in the language defined by the SPARQL grammar; or,</li>
            <li>500 if the service fails to execute the query. SPARQL Protocol services may also return a 500 response code if they refuse to execute a query. This response does not indicate whether
            the server may or may not process a subsequent, identical request or requests.</li>
          </ul>
          <p>The response body of a failed query request is implementation defined. Implementations <strong>may</strong> use HTTP content negotiation to provide human-readable or machine-processable
          (or both) information about the failed query request.</p>
          <p>A protocol service <strong>may</strong> use other 4XX or 5XX HTTP response codes for other failure conditions, as per HTTP.</p>
        </section>
      </section>
      <section id="update-operation">
        <h3>Update Operation</h3>
        <p>
          The <code>update</code> operation is used to send a SPARQL update request to a service. The update operation <strong>must</strong> be invoked using the HTTP POST method. Client requests
          for this operation <strong>must</strong> include exactly one SPARQL update request string (parameter name: <code>update</code>) and <strong>may</strong> include zero or more default graph
          URIs (parameter name: <code>using-graph-uri</code>) and named graph URIs (parameter name: <code>using-named-graph-uri</code>). The response to an update request indicates success or failure
          of the request via HTTP response status code.</p>
        <span class="doc-ref" id="update-summary"></span>
        <table style="margin-left: auto; margin-right: auto; border-color: rgb(0, 0, 0); border-collapse: collapse; padding: 5px; border: 1px">
          <tbody>
            <tr>
              <th>&nbsp;</th>
              <th>HTTP Method</th>
              <th>Query String Parameters</th>
              <th>Request Content Type</th>
              <th>Request Message Body</th>
            </tr>
            <tr>
              <th>update via URL-encoded POST</th>
              <td>POST</td>
              <td>None</td>
              <td><code>application/x-www-form-urlencoded</code></td>
              <td>URL-encoded, ampersand-separated query parameters.<br>
              <code>update</code> (exactly 1)<br>
              <code>using-graph-uri</code> (0 or more)<br>
              <code>using-named-graph-uri</code> (0 or more)</td>
            </tr>
            <tr>
              <th>update via POST directly</th>
              <td>POST</td>
              <td><code>using-graph-uri</code> (0 or more)<br>
              <code>using-named-graph-uri</code> (0 or more)</td>
              <td><code>application/sparql-update</code></td>
              <td>Unencoded SPARQL update request string</td>
            </tr>
          </tbody>
        </table>
        <p>The <code>update</code> request's parameters <strong>must</strong> be sent according to one of these two options:</p>
        <section id="update-via-post-urlencoded">
          <h4><code>update</code> via POST with URL-encoded parameters</h4>
          <p>Protocol clients <strong>may</strong> send update protocol requests via the HTTP POST method by URL encoding the parameters. When using this approach, clients <strong>must</strong> URL
          <a data-cite="rfc3986#">percent encode</a> all parameters and include them as parameters within the request body via the
          <code>application/x-www-form-urlencoded</code> media type with the name given above. Parameters <strong>must</strong> be separated with the ampersand (<code>&amp;</code>) character. Clients
          may include the parameters in any order. The content type header of the HTTP request <strong>must</strong> be set to <code>application/x-www-form-urlencoded</code>.</p>
        </section>
        <section id="update-via-post-direct">
          <h4><code>update</code> via POST directly</h4>
          <p>Protocol clients <strong>may</strong> send update protocol requests via the HTTP POST method by including the update request directly and unencoded as the HTTP request message body. When
          using this approach, clients <strong>must</strong> include the SPARQL update request string, unencoded, and nothing else as the message body of the request. Clients <strong>must</strong>
          set the content type header of the HTTP request to <code>application/sparql-update</code>. Clients <strong>may</strong> include the optional <code>using-graph-uri</code> and
          <code>using-named-graph-uri</code> parameters as HTTP query string parameters in the request URI.</p>
        </section>
        <section id="update-dataset">
          <h4>Specifying an RDF Dataset</h4>
          <p>SPARQL Update requests are executed against a Graph Store, a mutable container of RDF graphs managed by a SPARQL service. The <code>WHERE</code> clause of a SPARQL update <a data-cite=
          "SPARQL12-UPDATE#deleteInsert">DELETE/INSERT operation</a> matches against data in an <a data-cite=
          "SPARQL12-QUERY#rdfDataset">RDF Dataset</a>, which is a subset of the Graph Store. The RDF Dataset for an update operation may be specified either in the operation
          string itself using the <code>USING</code>, <code>USING NAMED</code>, and/or <code>WITH</code> keywords, or it may be specified via the <code>using-graph-uri</code> and
          <code>using-named-graph-uri</code> parameters.</p>
          <p>It is an error to supply the <code>using-graph-uri</code> or <code>using-named-graph-uri</code> parameters when using this protocol to convey a SPARQL 1.2 Update request that contains an
          operation that uses the <code>USING</code>, <code>USING NAMED</code>, or <code>WITH</code> clause.</p>
          <p>A SPARQL Update processor should treat each occurrence of the <code>using-graph-uri=g</code> parameter in an update protocol operation as if a <code>USING &lt;g&gt;</code> clause were
          included for every operation in the SPARQL 1.2 Update request. Similarly, a SPARQL Update processor should treat each occurrence of the <code>using-named-graph-uri=g</code> parameter in an
          update protocol operation as if a <code>USING NAMED &lt;g&gt;</code> clause were included for every operation in the SPARQL 1.2 Update request.</p>
        </section>
        <section id="update-success">
          <h4>Success Responses</h4>
          <p>The SPARQL Protocol uses the response status codes defined in HTTP to indicate the success or failure of an operation. Consult the <a data-cite="rfc9110#status.codes">HTTP specification</a> 
          [[RFC9110]] for detailed definitions of each status code. While a protocol service
          <strong>should</strong> use a <code>2XX</code> HTTP response code for an update request that is successfully processed, it <strong>may</strong> choose instead to use a <code>3XX</code> 
          response code as per HTTP.</p>
          <p>The response body of a successful update request is implementation defined. Implementations <strong>may</strong> use HTTP content negotiation to provide both human-readable and
          machine-processable information about the completed update request.</p>
        </section>
        <section id="update-failure">
          <h4>Failure Responses</h4>
          <p>The HTTP response code for an unsuccessful update request should be:</p>
          <ul>
            <li>400 if the SPARQL update request string is not a legal sequence of characters in the language defined by the SPARQL Update grammar; or,</li>
            <li>500 if the service fails to execute the update request. SPARQL Protocol services may also return a 500 response code if they refuse to execute an update request. This response does
            not indicate whether the server may or may not process a subsequent, identical request or requests.</li>
          </ul>
          <p>The response body of a failed update request is implementation defined. Implementations <strong>may</strong> use HTTP content negotiation to provide human-readable or machine-processable
          (or both) information about the failed update request.</p>
          <p>A protocol service <strong>may</strong> use other 4XX or 5XX HTTP response codes for other failure conditions, as per HTTP.</p>
        </section>
      </section>
      <section id="base-iri">
        <h3>Determining the Base IRI</h3>
        <p>The <code>BASE</code> keyword in a SPARQL query or a SPARQL update request string defines the Base IRI used to resolve relative IRIs per [[[RFC3986]]] section 5.1.1, "Base URI Embedded in Content". The SPARQL Protocol
        does not dereference query URIs so section 5.1.3 does not apply. Finally, per section 5.1.4, SPARQL Protocol services <strong>must</strong> define their own base URI, which
        <strong>may</strong> be the service endpoint.</p>
      </section>
    </section>
    <section id="examples">
      <h2>Example SPARQL Protocol Requests (informative)</h2>
      <p>The following HTTP trace examples illustrate invocation of the <code>query</code> and <code>update</code> operations under several different scenarios. Some example traces are abstracted
      from complete HTTP traces in these ways:</p>
      <ol>
        <li>In some examples the string "<i>EncodedQuery</i>" represents the URL-encoded string equivalent of the SPARQL query string given in the example; the string "<i>UnencodedQuery</i>"
        represents the exact SPARQL query string given in the example without any encoding.</li>
        <li>For <code>query</code> operation examples, only partial response bodies, containing the query results, are displayed.</li>
      </ol>
      <section id="query-bindings-http-examples">
        <h3>Examples of SPARQL Query</h3>
        <section id="select-svcsupplied">
          <h4>SELECT with service-supplied RDF Dataset</h4>
          <p>This SPARQL query</p>
          <div id="div-select-svcsupplied">
            <pre class="query nohighlight">PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt; 
SELECT ?book ?who 
WHERE { ?book dc:creator ?who }</pre>
            <p>is conveyed via HTTP GET to the SPARQL query service, <code>/http://www.example/sparql/</code>, as illustrated in this HTTP trace:</p>
            <pre class="req nohighlight">GET /sparql/?<b>query</b>=PREFIX%20dc%3A%20%3Chttp%3A%2F%2Fpurl.org%2Fdc%2Felements%2F1.1%2F%3E%20%0ASELECT%20%3Fbook%20%3Fwho%20%0AWHERE%20%7B%20%3Fbook%20dc%3Acreator%20%3Fwho%20%7D%0A HTTP/1.1
Host: www.example
User-agent: my-sparql-client/0.1</pre>
            <p>That query against the service-supplied RDF Dataset, executed by that SPARQL query service, returns the following query result:</p>
            <pre class="resp nohighlight">HTTP/1.1 200 OK
Date: Fri, 06 May 2005 20:55:12 GMT
Server: Apache/1.3.29 (Unix) PHP/4.3.4 DAV/1.0.3
Connection: close
Content-Type: application/sparql-results+xml

&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;

 &lt;head&gt;
   &lt;variable name="book"/&gt;
   &lt;variable name="who"/&gt;
 &lt;/head&gt;
 &lt;results&gt;
   &lt;result&gt;
     &lt;binding name="book"&gt;&lt;uri&gt;http://www.example/book/book5&lt;/uri&gt;&lt;/binding&gt;
     &lt;binding name="who"&gt;&lt;bnode&gt;r29392923r2922&lt;/bnode&gt;&lt;/binding&gt;
   &lt;/result&gt;
...
&lt;/sparql&gt; </pre>
          </div>
        </section>
        <section id="select-simple">
          <h4>SELECT with simple RDF Dataset</h4>
          <p>This SPARQL query</p>
          <div id="div-select-simple">
            <pre class="query nohighlight">PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt; 
SELECT ?book ?who 
WHERE { ?book dc:creator ?who }</pre>
            <p>is conveyed to the SPARQL query service, <code>/http://www.other.example/sparql/</code>, as illustrated in this HTTP trace:</p>
            <pre class="req nohighlight">GET /sparql/?<b>query</b>=PREFIX%20dc%3A%20%3Chttp%3A%2F%2Fpurl.org%2Fdc%2Felements%2F1.1%2F%3E%20%0ASELECT%20%3Fbook%20%3Fwho%20%0AWHERE%20%7B%20%3Fbook%20dc%3Acreator%20%3Fwho%20%7D%0A&amp;<b>default-graph-uri</b>=http%3A%2F%2Fwww.other.example%2Fbooks HTTP/1.1
Host: www.other.example
User-agent: my-sparql-client/0.1
</pre>
            <p>That query — against the RDF Dataset identified by the value of the <code>default-graph-uri</code> parameter, <code>/http://www.other.example/books</code> — executed by that SPARQL query
            service, returns the following query result:</p>
            <pre class="resp nohighlight">HTTP/1.1 200 OK
Date: Fri, 06 May 2005 20:55:12 GMT
Server: Apache/1.3.29 (Unix) PHP/4.3.4 DAV/1.0.3
Connection: close
Content-Type: application/sparql-results+xml

&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
 &lt;head&gt;
   &lt;variable name="book"/&gt;
   &lt;variable name="who"/&gt;
 &lt;/head&gt;
...
&lt;/sparql&gt; </pre>
          </div>
        </section>
        <section id="construct-simple">
          <h4>CONSTRUCT with simple RDF dataset and HTTP content negotiation</h4>
          <p>This SPARQL query</p>
          <div id="div-construct-simple">
            <pre class="query nohighlight">PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX myfoaf: &lt;http://www.example/jose/foaf.rdf#&gt;

CONSTRUCT { myfoaf:jose foaf:depiction &lt;http://www.example/jose/jose.jpg&gt;.
            myfoaf:jose foaf:schoolHomepage &lt;http://www.edu.example/&gt;.
            ?s ?p ?o.}
WHERE { ?s ?p ?o. myfoaf:jose foaf:nick "Jo".
       FILTER ( ! (?s = myfoaf:kendall &amp;&amp; ?p = foaf:knows &amp;&amp; ?o = myfoaf:edd ) 
              &amp;&amp; ! ( ?s = myfoaf:julia &amp;&amp; ?p = foaf:mbox &amp;&amp; ?o = &lt;mailto:julia@mail.example&gt; )
              &amp;&amp; ! ( ?s = myfoaf:julia &amp;&amp; ?p = rdf:type &amp;&amp; ?o = foaf:Person))
}</pre>
            <p>is conveyed to the SPARQL query service, <code>/http://www.example/sparql/</code>, as illustrated in this HTTP trace:</p>
            <pre class="req nohighlight">GET /sparql/?<b>query</b>=<i>EncodedQuery</i>&amp;<b>default-graph-uri</b>=http%3A%2F%2Fwww.example%2Fjose-foaf.rdf HTTP/1.1
Host: www.example
User-agent: sparql-client/0.1
Accept: text/turtle, application/rdf+xml</pre>
            <p>With the response illustrated here:</p>
            <pre class="resp nohighlight">HTTP/1.1 200 OK
Date: Fri, 06 May 2005 20:55:11 GMT
Server: Apache/1.3.29 (Unix)
Connection: close
Content-Type: text/turtle

@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;.
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt;.
@prefix myfoaf: &lt;http://www.example/jose/foaf.rdf#&gt;.

myfoaf:jose foaf:name "Jose Jimeñez";
            foaf:depiction &lt;http://www.example/jose/jose.jpg&gt;;
            foaf:nick "Jo";
...</pre>
          </div>
        </section>
        <section id="ask-simple">
          <h4>ASK with simple RDF Dataset</h4>
          <p>This SPARQL query</p>
          <div id="div-ask-simple">
            <pre class="query nohighlight">PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt; 
ASK WHERE { ?book dc:creator "J.K. Rowling"}</pre>
            <p>is conveyed to the SPARQL query service, <code>/http://www.example/sparql/</code>, as illustrated in this HTTP trace:</p>
            <pre class="req nohighlight">GET /sparql/?<b>query</b>=<i>EncodedQuery</i>&amp;<b>default-graph-uri</b>=http%3A%2F%2Fwww.example%2Fbooks HTTP/1.1
Host: www.example
User-agent: sparql-client/0.1
</pre>
            <p>With the response illustrated here:</p>
            <pre class="resp nohighlight">HTTP/1.1 200 OK
Date: Fri, 06 May 2005 20:48:25 GMT
Server: Apache/1.3.29 (Unix) PHP/4.3.4 DAV/1.0.3
Connection: close
Content-Type: application/sparql-results+xml

&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
 &lt;head&gt;&lt;/head&gt;
 &lt;boolean&gt;true&lt;/boolean&gt;
&lt;/sparql&gt;</pre>
          </div>
        </section>
        <section id="describe-simple">
          <h4>DESCRIBE with simple RDF Dataset</h4>
          <p>This SPARQL query</p>
          <div id="div-describe-simple">
            <pre class="query nohighlight">PREFIX books: &lt;http://www.example/book/&gt;
DESCRIBE books:book6</pre>
            <p>is conveyed to the SPARQL query service, <code>/http://www.example/sparql/</code>, as illustrated here:</p>
            <pre class="req nohighlight">GET /sparql/?<b>query</b>=<i>EncodedQuery</i>&amp;<b>default-graph-uri</b>=http%3A%2F%2Fwww.example%2Fbooks HTTP/1.1
Host: www.example
User-agent: sparql-client/0.1</pre>
            <p>With the response illustrated here:</p>
            <pre class="resp nohighlight">HTTP/1.1 200 OK
Date: Wed, 03 Aug 2005 12:48:25 GMT
Server: Apache/1.3.29 (Unix) PHP/4.3.4 DAV/1.0.3
Connection: close
Content-Type:  application/rdf+xml

&lt;?xml version="1.0"?&gt;
&lt;rdf:RDF 
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:books="http://www.example/book/"
    xmlns:dc="http://purl.org/dc/elements/1.1/" &gt;
  &lt;rdf:Description rdf:about="http://www.example/book/book6"&gt;
    &lt;dc:title&gt;Example Book #6 &lt;/dc:title&gt;
  &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;</pre>
          </div>
        </section>
        <section id="select-complex">
          <h4>SELECT with complex RDF Dataset</h4>
          <p>This SPARQL query</p>
          <div id="div-select-complex">
            <pre class="query nohighlight">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?who ?g ?mbox
WHERE {  ?g dc:publisher ?who .
   GRAPH ?g { ?x foaf:mbox ?mbox }
}</pre>
            <p>is conveyed to the SPARQL query service, http://www.example/sparql/, as illustrated here (with line breaks for legibility):</p>
            <pre class="req nohighlight">GET /sparql/?<b>query</b>=<i>EncodedQuery</i>&amp;<b>default-graph-uri</b>=http%3A%2F%2Fwww.example%2Fpublishers
&amp;<b>default-graph-uri</b>=http%3A%2F%2Fwww.example%2Fmorepublishers&amp;<b>named-graph-uri</b>=http%3A%2F%2Fyour.example%2Ffoaf-alice
&amp;<b>named-graph-uri</b>=http%3A%2F%2Fwww.example%2Ffoaf-bob&amp;<b>named-graph-uri</b>=http%3A%2F%2Fwww.example%2Ffoaf-susan
&amp;<b>named-graph-uri</b>=http%3A%2F%2Fthis.example%2Fjohn%2Ffoaf
Host: www.example
User-agent: sparql-client/0.1</pre>
            <p>With the response illustrated here:</p>
            <pre class="resp nohighlight">HTTP/1.1 200 OK
Date: Wed, 03 Aug 2005 12:48:25 GMT
Server: Apache/1.3.29 (Unix) PHP/4.3.4 DAV/1.0.3
Connection: close
Content-Type:  application/sparql-results+xml

&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
  &lt;head&gt;
    &lt;variable name="who"/&gt;
    &lt;variable name="g"/&gt;
    &lt;variable name="mbox"/&gt;
  &lt;/head&gt;
...
&lt;/sparql&gt;</pre>
          </div>
        </section>
        <section id="select-queryonly">
          <h4>SELECT with query-only RDF Dataset</h4>
          <p>This SPARQL query</p>
          <div id="div-select-queryonly">
            <pre class="query nohighlight">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?who ?g ?mbox
FROM &lt;http://www.example/publishers&gt;
FROM NAMED &lt;http://www.example/alice&gt;
FROM NAMED &lt;http://www.example/bob&gt;
WHERE { ?g dc:publisher ?who .
        GRAPH ?g { ?x foaf:mbox ?mbox }
}</pre>
            <p>is conveyed to the SPARQL query service, <code>/http://www.example/sparql/</code>, as illustrated in this HTTP trace:</p>
            <pre class="req nohighlight">GET /sparql/?<b>query</b>=<i>EncodedQuery</i> HTTP/1.1
Host: www.example
User-agent: sparql-client/0.1</pre>
            <p>With the response illustrated here:</p>
            <pre class="resp nohighlight">HTTP/1.1 200 OK
Date: Wed, 03 Aug 2005 12:48:25 GMT
Server: Apache/1.3.29 (Unix) PHP/4.3.4 DAV/1.0.3
Connection: close
Content-Type: application/sparql-results+xml

&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
...
&lt;/sparql&gt;</pre>
          </div>
        </section>
        <section id="select-ambiguous">
          <h4>SELECT with ambiguous RDF Dataset</h4>
          <div id="div-select-ambiguous">
            <p>This SPARQL query</p>
            <pre class="query nohighlight">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?who ?g ?mbox
FROM &lt;http://www.example/publishers&gt;
FROM NAMED &lt;http://www.example/john&gt;
FROM NAMED &lt;http://www.example/susan&gt;
WHERE { ?g dc:publisher ?who .
        GRAPH ?g { ?x foaf:mbox ?mbox }
}</pre>
            <p>is conveyed to the SPARQL query service, <code>/http://www.example/sparql/</code>, as illustrated in this HTTP trace:</p>
            <pre class="req nohighlight">GET /sparql/?<b>query</b>=<i>EncodedQuery</i>&amp;<b>default-graph-uri</b>=http%3A%2F%2Fwww.example%2Fmorepublishers
&amp;<b>named-graph-uri</b>=http%3A%2F%2Fwww.example%2Fbob&amp;<b>named-graph-uri</b>=http%3A%2F%2Fwww.example%2Falice HTTP/1.1
Host: www.example
User-agent: sparql-client/0.1</pre>
            <p>This protocol operation contains an ambiguous RDF Dataset: the dataset specified in the query is different than the one specified in the protocol (by way of
            <code>default-graph-uri</code> and <code>named-graph-uri</code> parameters). A conformant SPARQL Protocol service must resolve this ambiguity by executing the query against the RDF
            Dataset specified in the protocol:</p>
            <pre class="resp nohighlight">HTTP/1.1 200 OK
Date: Wed, 03 Aug 2005 12:48:25 GMT
Server: Apache/1.3.29 (Unix) PHP/4.3.4 DAV/1.0.3
Connection: close
Content-Type: application/sparql-results+xml

&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
  &lt;head&gt;
    &lt;variable name="who"/&gt;
    &lt;variable name="g"/&gt;
    &lt;variable name="mbox"/&gt;
  &lt;/head&gt;
  &lt;results&gt;
    &lt;result&gt;
      &lt;binding name="who"&gt;
        &lt;literal&gt;Bob Hacker&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name="g"&gt;
        &lt;uri&gt;http://www.example/bob&lt;/uri&gt;
      &lt;/binding&gt;
      &lt;binding name="mbox"&gt;
        &lt;uri&gt;mailto:bob@oldcorp.example&lt;/uri&gt;
      &lt;/binding&gt;
    &lt;/result&gt;
    &lt;result&gt;
      &lt;binding name="who"&gt;
        &lt;literal&gt;Alice Hacker&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name="g"&gt;
        &lt;uri&gt;http://www.example/alice&lt;/uri&gt;
      &lt;/binding&gt;
      &lt;binding name="mbox"&gt;
        &lt;uri&gt;mailto:alice@work.example&lt;/uri&gt;
      &lt;/binding&gt;
    &lt;/result&gt;
  &lt;/results&gt;
&lt;/sparql&gt;</pre>
          </div>
        </section>
        <section id="select-malformed">
          <h4>SELECT with malformed query fault</h4>
          <p>This syntactically invalid SPARQL query</p>
          <div id="div-select-malformed">
            <pre class="query nohighlight">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
WHERE { ?x foaf:name ?name
ORDER BY ?name }</pre>
            <p>is conveyed to the SPARQL query service, <code>/http://www.example/sparql/</code>, as illustrated in this HTTP trace:</p>
            <pre class="req nohighlight">GET /sparql/?<b>query</b>=<i>EncodedQuery</i>&amp;<b>default-graph-uri</b>=http%3A%2F%2Fwww.example%2Fmorepublishers HTTP/1.1
Host: www.example
User-agent: sparql-client/0.1</pre>
            <p>With the error response illustrated here:</p>
            <pre class="resp nohighlight">HTTP/1.1 400 Bad Request
Date: Wed, 03 Aug 2005 12:48:25 GMT
Server: Apache/1.3.29 (Unix) PHP/4.3.4 DAV/1.0.3
Connection: close
Content-Type: text/plain; charset=UTF-8

4:syntax error, unexpected ORDER, expecting '}'</pre>
          </div>
        </section>
        <section id="select-refused">
          <h4>SELECT with query request refused fault</h4>
          <p>This SPARQL query</p>
          <div id="div-select-refused">
            <pre class="query nohighlight">PREFIX bio: &lt;http://bio.example/schema/#&gt;
SELECT ?valence
FROM &lt;http://another.example/protein-db.rdf&gt;
WHERE { ?x bio:protein ?valence }
ORDER BY ?valence</pre>
            <p>is conveyed to the SPARQL query service, <code>/http://www.example/sparql/</code>, as illustrated in this HTTP trace:</p>
            <pre class="req nohighlight">GET /sparql/?<b>query</b>=<i>EncodedQuery</i>&amp;<b>default-graph-uri</b>=http%3A%2F%2Fanother.example%2Fprotein-db.rdf HTTP/1.1
Host: www.example
User-agent: sparql-client/0.1</pre>
            <p>With the error response illustrated here:</p>
            <pre class="resp nohighlight">HTTP/1.1 500 Internal Server Error
Date: Wed, 03 Aug 2005 12:48:25 GMT
Server: Apache/1.3.29 (Unix) PHP/4.3.4 DAV/1.0.3
Connection: close
Content-Type: text/plain

SPARQL Processing Service: Query Request Refused

Your request could not be processed because http://another.example/protein-db.rdf
could not be retrieved within the time alloted.
</pre>
          </div>
        </section>
        <section id="select-longpost">
          <h4>Long SELECT query using POST with URL encoding</h4>
          <p>Some SPARQL queries, perhaps machine generated, may be longer than can be reliably conveyed by way of the HTTP GET binding described in <a href="#query-via-get">2.1.1 query via GET</a>.
          In those cases the POST binding described in <a href="#query-via-post-urlencoded">2.1.2 query via POST with URL-encoded parameters</a> may be used. This SPARQL query</p>
          <div id="div-select-longpost">
            <pre class="query nohighlight">PREFIX : &lt;http://www.w3.org/2002/12/cal/icaltzd#&gt;
PREFIX Chi: &lt;http://www.w3.org/2002/12/cal/test/Chiefs.ics#&gt;
PREFIX New: &lt;http://www.w3.org/2002/12/cal/tzd/America/New_York#&gt;
PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?summary
WHERE {
    {
        Chi:D603E2AC-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-09-08T16:00:00"^^New:tz;
         :dtstamp "2002-09-06T03:09:27Z"^^xsd:dateTime;
         :dtstart "2002-09-08T13:00:00"^^New:tz;
         :summary ?summary;
         :uid "D603E2AC-C1C9-11D6-9446-003065F198AC" .
        }
        UNION
    {
        Chi:D603E90B-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-09-15T16:00:00"^^New:tz;
         :dtstamp "2002-09-06T03:10:19Z"^^xsd:dateTime;
         :dtstart "2002-09-15T13:00:00"^^New:tz;
         :summary ?summary;
         :uid "D603E90B-C1C9-11D6-9446-003065F198AC" .
        }
        UNION
    {
        Chi:D603ED6E-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-09-22T16:00:00"^^New:tz;
         :dtstamp "2002-09-06T03:11:05Z"^^xsd:dateTime;
         :dtstart "2002-09-22T13:00:00"^^New:tz;
         :summary ?summary;
         :uid "D603ED6E-C1C9-11D6-9446-003065F198AC" .
        }
        UNION
    {
        Chi:D603F18C-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-09-29T16:00:00"^^New:tz;
         :dtstamp "2002-09-06T03:15:46Z"^^xsd:dateTime;
         :dtstart "2002-09-29T13:00:00"^^New:tz;
         :summary ?summary;
         :uid "D603F18C-C1C9-11D6-9446-003065F198AC" .
        }
        UNION
    {
        Chi:D603F5B7-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-11-04"^^xsd:date;
         :dtstamp "2002-09-06T03:12:53Z"^^xsd:dateTime;
         :dtstart "2002-11-03"^^xsd:date;
         :summary ?summary;
         :uid "D603F5B7-C1C9-11D6-9446-003065F198AC" .
        }
        UNION
    {
        Chi:D603F9D7-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-11-10T20:15:00"^^New:tz;
         :dtstamp "2002-09-06T03:14:12Z"^^xsd:dateTime;
         :dtstart "2002-11-10T17:15:00"^^New:tz;
         :summary ?summary;
         :uid "D603F9D7-C1C9-11D6-9446-003065F198AC" .
    }
        UNION
    {
        Chi:D604022C-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-11-17T17:00:00"^^New:tz;
         :dtstamp "2002-09-06T03:14:51Z"^^xsd:dateTime;
         :dtstart "2002-11-17T14:00:00"^^New:tz;
         :summary ?summary;
         :uid "D604022C-C1C9-11D6-9446-003065F198AC" .
    }
        UNION
    {
        Chi:D604065C-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-10-06T19:05:00"^^New:tz;
         :dtstamp "2002-09-06T03:16:54Z"^^xsd:dateTime;
         :dtstart "2002-10-06T16:05:00"^^New:tz;
         :summary ?summary;
         :uid "D604065C-C1C9-11D6-9446-003065F198AC" .
    }
        UNION
    {
        Chi:D6040A7E-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-10-13T19:15:00"^^New:tz;
         :dtstamp "2002-09-06T03:17:51Z"^^xsd:dateTime;
         :dtstart "2002-10-13T16:15:00"^^New:tz;
         :summary ?summary;
         :uid "D6040A7E-C1C9-11D6-9446-003065F198AC" .
    }
        UNION
    {
        Chi:D6040E96-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-10-20T16:00:00"^^New:tz;
         :dtstamp "2002-09-06T03:18:32Z"^^xsd:dateTime;
         :dtstart "2002-10-20T13:00:00"^^New:tz;
         :summary ?summary;
         :uid "D6040E96-C1C9-11D6-9446-003065F198AC" .
    }
        UNION
    {
        Chi:D6041270-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-10-27T17:00:00"^^New:tz;
         :dtstamp "2002-09-06T03:19:15Z"^^xsd:dateTime;
         :dtstart "2002-10-27T14:00:00"^^New:tz;
         :summary ?summary;
         :uid "D6041270-C1C9-11D6-9446-003065F198AC" .
    }
        UNION
    {
        Chi:D6041673-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-11-24T20:05:00"^^New:tz;
         :dtstamp "2002-09-06T03:22:09Z"^^xsd:dateTime;
         :dtstart "2002-11-24T17:05:00"^^New:tz;
         :summary ?summary;
         :uid "D6041673-C1C9-11D6-9446-003065F198AC" .
    }
        UNION
    {
        Chi:D6041A73-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-12-01T17:00:00"^^New:tz;
         :dtstamp "2002-09-06T03:22:52Z"^^xsd:dateTime;
         :dtstart "2002-12-01T14:00:00"^^New:tz;
         :summary ?summary;
         :uid "D6041A73-C1C9-11D6-9446-003065F198AC" .
    }
        UNION
    {
        Chi:D60421EF-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-12-08T17:00:00"^^New:tz;
         :dtstamp "2002-09-06T03:24:04Z"^^xsd:dateTime;
         :dtstart "2002-12-08T14:00:00"^^New:tz;
         :summary ?summary;
         :uid "D60421EF-C1C9-11D6-9446-003065F198AC" .
    }
        UNION
    {
        Chi:D6042660-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-12-15T20:05:00"^^New:tz;
         :dtstamp "2002-09-06T03:25:03Z"^^xsd:dateTime;
         :dtstart "2002-12-15T17:05:00"^^New:tz;
         :summary ?summary;
         :uid "D6042660-C1C9-11D6-9446-003065F198AC" .
    }
        UNION
    {
        Chi:D6042A93-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-12-22T17:00:00"^^New:tz;
         :dtstamp "2002-09-06T03:25:47Z"^^xsd:dateTime;
         :dtstart "2002-12-22T14:00:00"^^New:tz;
         :summary ?summary;
         :uid "D6042A93-C1C9-11D6-9446-003065F198AC" .
    }
        UNION
    {
        Chi:D6042EDF-C1C9-11D6-9446-003065F198AC     a :Vevent;
         :dtend "2002-12-28T21:00:00"^^New:tz;
         :dtstamp "2002-09-06T03:26:51Z"^^xsd:dateTime;
         :dtstart "2002-12-28T18:00:00"^^New:tz;
         :summary ?summary;
         :uid "D6042EDF-C1C9-11D6-9446-003065F198AC" .
    }
}</pre>
            <p>is conveyed to the SPARQL query service, <code>/http://www.example/sparql/</code>, as illustrated in this HTTP trace:</p>
            <pre class="req nohighlight">POST /sparql/ HTTP/1.1
Host: www.example
User-agent: sparql-client/0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 9461

<b>query</b>=<i>EncodedQuery</i>&amp;<b>default-graph-uri</b>=http%3A%2F%2Fanother.example%2Fcalendar.rdf</pre>
            <p>With the response illustrated here:</p>
            <pre class="resp nohighlight">HTTP/1.1 200 OK
Date: Wed, 03 Aug 2005 12:48:25 GMT
Server: Apache/1.3.29 (Unix) PHP/4.3.4 DAV/1.0.3
Connection: close
Content-Type: application/sparql-results+xml

&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
    &lt;head&gt;
        &lt;variable name="summary"/&gt;
    &lt;/head&gt;
    &lt;results&gt;
        &lt;result&gt;
            &lt;binding name="summary"&gt;
                &lt;literal&gt;Chiefs vs. Cleveland @ Cleveland Stadium&lt;/literal&gt;
            &lt;/binding&gt;
        &lt;/result&gt;
        &lt;result&gt;
            &lt;binding name="summary"&gt;
                &lt;literal&gt;Chiefs vs. Jacksonville @ Arrowhead Stadium&lt;/literal&gt;
            &lt;/binding&gt;
        &lt;/result&gt;
        &lt;result&gt;
            &lt;binding name="summary"&gt;
                &lt;literal&gt;Chiefs vs. New England @ Gillette Stadium&lt;/literal&gt;
            &lt;/binding&gt;
        &lt;/result&gt;
        ...
        &lt;result&gt;
            &lt;binding name="summary"&gt;
                &lt;literal&gt;Chiefs vs. Oakland @ Network Associates Coliseum&lt;/literal&gt;
            &lt;/binding&gt;
        &lt;/result&gt;
    &lt;/results&gt;
&lt;/sparql&gt;</pre>
          </div>
        </section>
        <section id="select-longpost-direct">
          <h4>Long SELECT query using direct POST</h4>
          <p>SPARQL queries may also be POSTed directly without URL encoding, as described in <a href="#query-via-post-direct">2.1.3 query via POST directly</a>. The same query used in the <a href=
          "#select-longpost">previous example</a> is conveyed to the SPARQL query service, <code>/http://www.example/sparql/</code>, as illustrated in this HTTP trace:</p>
          <pre class="req nohighlight">POST /sparql/?default-graph-uri=http%3A%2F%2Fanother.example%2Fcalendar.rdf HTTP/1.1
Host: www.example
User-agent: sparql-client/0.1
Content-Type: application/sparql-query

<i>UnencodedQuery</i></pre>
          <p>With the same response as in the previous example.</p>
        </section>
        <section id="select-kanji">
          <h4>SELECT with internationalization</h4>
          <p>SPARQL queries may include internationalized characters or character sets. This SPARQL query</p>
          <div id="div-select-kanji">
            <pre class="query nohighlight">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX 食: &lt;http://www.w3.org/2001/sw/DataAccess/tests/data/i18n/kanji.ttl#&gt;
SELECT ?name ?food 
WHERE { [ foaf:name ?name ; 食:食べる ?food ] . }</pre>
            <p>is conveyed to the SPARQL query service, <code>/http://www.example/sparql/</code>, as illustrated in this HTTP trace:</p>
            <pre class="req nohighlight">GET /sparql/?<b>query=PREFIX%20foaf%3A%20%3Chttp%3A%2F%2Fxmlns.com%2Ffoaf%2F0.1%2F%3E%0APREFIX%20%E9%A3%9F%3A%20%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2Fsw%2FDataAccess%2Ftests%2Fdata%2Fi18n%2Fkanji.ttl%23%3E%0ASELECT%20%3Fname%20%3Ffood%20%0AWHERE%20%7B%20%5B%20foaf%3Aname%20%3Fname%20%3B%20%E9%A3%9F%3A%E9%A3%9F%E3%81%B9%E3%82%8B%20%3Ffood%20%5D%20.%20%7D</b>
Host: www.example
User-agent: sparql-client/0.1</pre>
            <pre class="resp nohighlight">HTTP/1.1 200 OK
Date: Wed, 03 Aug 2005 12:48:25 GMT
Server: Apache/1.3.29 (Unix)
Connection: close
Content-Type: application/sparql-results+xml

&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
...
&lt;/sparql&gt;</pre>
          </div>
        </section>
        <section id="select-quoted">
          <h4>SELECT with quoted triple patterns</h4>
          <p>SPARQL queries can target quoted triples. This SPARQL query</p>
          <div id="div-select-quoted">
            <pre class="query nohighlight">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX ex: &lt;http://example.org/&gt;
SELECT ?name ?person
WHERE { &lt;&lt; _:a foaf:name ?name &gt;&gt; ex:statedBy ?person . }</pre>
            <p>is conveyed to the SPARQL query service, <code>http://www.example/sparql/</code>, as illustrated in this HTTP trace:</p>
            <pre class="req nohighlight">GET /sparql/?<b>query=PREFIX%20foaf%3A%20%3Chttp%3A%2F%2Fxmlns.com%2Ffoaf%2F0.1%2F%3E%0APREFIX%20ex%3A%20%3Chttp%3A%2F%2Fexample.org%2F%3E%0ASELECT%20%3Fname%20%3Fperson%20%0AWHERE%20%7B%20%3C%3C%20_%3Aa%20foaf%3Aname%20%3Fname%20%3E%3E%20ex%3AstatedBy%20%3Fperson%20.%20%7D</b>
Host: www.example
User-agent: sparql-client/0.1</pre>
            <pre class="resp nohighlight">HTTP/1.1 200 OK
Date: Wed, 03 Aug 2005 12:48:25 GMT
Server: Apache/1.3.29 (Unix)
Connection: close
Content-Type: application/sparql-results+xml

&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
...
&lt;/sparql&gt;</pre>
          </div>
        </section>
      </section>
      <section id="update-bindings-http-examples">
        <h3>Examples of SPARQL Update</h3>
        <section id="update-urlencoded-simple">
          <h4>UPDATE using URL-encoded parameters</h4>
          <p>An example request, which is a serialisation of a request sent to <code>http://localhost:8888/test</code> for the query <code>INSERT DATA { &lt;a&gt; &lt;p&gt; &lt;b&gt; }</code> is
          shown below using the URL-encoded parameter form.</p>
          <pre class="req nohighlight">POST /test HTTP/1.1
Host: localhost:8888
Accept: text/plain
Content-Length: 62
Content-Type: application/x-www-form-urlencoded

update=INSERT%20DATA%20%7B%20%3Ca%3E%20%3Cp%3E%20%3Cb%3E%20%7D
</pre>
        </section>
        <section id="update-direct-simple">
          <h4>UPDATE using POST directly</h4>
          <p>Update requests may be sent as a POST request with a Content-Type of <code>application/sparql-update</code>:</p>
          <pre class="req nohighlight">POST /test HTTP/1.1
Host: localhost:8888
Accept: */*
Content-Type: application/sparql-update
Content-Length: 27

INSERT DATA { &lt;a&gt; &lt;p&gt; &lt;b&gt; }</pre>
        </section>
        <section id="update-direct-simple-dataset">
          <h4>UPDATE specifying dataset and using POST directly</h4>
          <p>A dataset for an update request may be specified using the <code>using-graph-uri</code> and <code>using-named-graph-uri</code> parameters. The serialisation of an example request sent to
          <code>http://localhost:8888/test</code> and specifying a dataset with default graph <code>http://localhost:8888/people</code> is shown below.</p>
          <pre class="req nohighlight">POST /test?using-graph-uri=http%3A%2F%2Flocalhost%3A8888%2Fpeople HTTP/1.1
Host: localhost:8888
Accept: */*
Content-Type: application/sparql-update
Content-Length: 136

PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
DELETE { ?person ?property ?value }
WHERE { ?person ?property ?value ; foaf:givenName 'Fred' }</pre>
        </section>
        <section id="update-urlencoded-multi">
          <h4>Multi-operation UPDATE using URL-encoded parameters</h4>
          <p>A sequence of multiple operations may be included in a single request, separated by a ';' (semicolon). The serialisation of an example request sent to
          <code>http://localhost:8888/test</code> for the query</p>
          <pre class="query nohighlight">DELETE DATA { &lt;a&gt; &lt;p&gt; &lt;old&gt; } ;
INSERT DATA { &lt;a&gt; &lt;p&gt; &lt;new&gt; }</pre>
          <p>is shown below using the URL-encoded parameter form.</p>
          <pre class="req nohighlight">POST /test HTTP/1.1
Host: localhost:8888
Accept: */*
Content-Type: application/x-www-form-urlencoded
Content-Length: 130

update=DELETE%20DATA%20%7B%20%3Ca%3E%20%3Cp%3E%20%3Cold%3E%20%7D%20%3B%0AINSERT%20DATA%20%7B%20%3Ca%3E%20%3Cp%3E%20%3Cnew%3E%20%7D</pre>
        </section>
        <section id="update-urlencoded-multi-dataset">
          <h4>Multi-operation UPDATE specifying dataset and using URL-encoded parameters</h4>
          <p>When POSTing an update request with URL-encoded parameters, the dataset parameters <code>using-graph-uri</code> and <code>using-named-graph-uri</code> are specified in the POST body with
          the serialized request. The serialisation of an example request sent to <code>http://localhost:8888/test</code> for the query</p>
          <pre class="query nohighlight">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
INSERT { GRAPH &lt;http://localhost:8888/people&gt; { ?person ?property ?value } }
WHERE { GRAPH ?g { ?person ?property ?value ; foaf:givenName 'Fred' } }</pre>
          <p>and specifying a dataset with the named graphs <code>http://localhost:8888/alice/foaf.rdf</code> and <code>http://localhost:8888/eve/foaf.rdf</code> is shown below.</p>
          <pre class="req nohighlight">POST /test HTTP/1.1
Host: localhost:8888
Accept: */*
Content-Type: application/x-www-form-urlencoded
Content-Length: 130

using-named-graph-uri=http%3A%2F%2Flocalhost%3A8888%2Falice%2Ffoaf.rdf&amp;using-named-graph-uri=http%3A%2F%2Flocalhost%3A8888%2Feve%2Ffoaf.rdf&amp;update=PREFIX%20foaf%3A%20%3Chttp%3A%2F%2Fxmlns.com%2Ffoaf%2F0.1%2F%3E%0AINSERT%20%7B%20GRAPH%20%3Chttp%3A%2F%2Flocalhost%3A8888%2Fpeople%3E%20%7B%20%3Fperson%20%3Fproperty%20%3Fvalue%20%7D%20%7D%0AWHERE%20%7B%20GRAPH%20%3Fg%20%7B%20%3Fperson%20%3Fproperty%20%3Fvalue%20%3B%20foaf%3AgivenName%20%27Fred%27%20%7D%20%7D
</pre>
        </section>
        <section id="update-direct-multi-dataset">
          <h4>Multi-operation UPDATE specifying dataset and using POST directly</h4>
          <p>The serialisation of an example request sent to <code>http://localhost:8888/test</code> and specifying a dataset with the named graphs <code>http://localhost:8888/alice/foaf.rdf</code>
          and <code>http://localhost:8888/eve/foaf.rdf</code> is shown below.</p>
          <pre class="req nohighlight">POST /test?using-named-graph-uri=http%3A%2F%2Flocalhost%3A8888%2Falice%2Ffoaf.rdf&amp;using-named-graph-uri=http%3A%2F%2Flocalhost%3A8888%2Feve%2Ffoaf.rdf HTTP/1.1
Host: localhost:8888
Accept: */*
Content-Type: application/sparql-update
Content-Length: 190

PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
INSERT { GRAPH &lt;http://localhost:8888/people&gt; { ?person ?property ?value } }
WHERE { GRAPH ?g { ?person ?property ?value ; foaf:givenName 'Fred' } }</pre>
        </section>
      </section>
    </section>
    <section id="policy">
      <h2>Policy Considerations</h2>
      <section id="policy-security">
        <h3>Security</h3>
        <p>There are at least two possible sources of denial-of-service attacks against SPARQL protocol services. First, under-constrained queries can result in very large numbers of results, which
        may require large expenditures of computing resources to process, assemble, or return. Another possible source are queries containing very complex — either because of resource size, the
        number of resources to be retrieved, or a combination of size and number — RDF Dataset descriptions, which the service may be unable to assemble without significant expenditure of resources,
        including bandwidth, CPU, or secondary storage. In some cases such expenditures may effectively constitute a denial-of-service attack. A SPARQL protocol service <strong>may</strong> place
        restrictions on the resources that it retrieves or on the rate at which external resources are retrieved. There may be other sources of denial-of-service attacks against SPARQL query
        processing services.</p>
        <p>Since a SPARQL protocol service may make HTTP requests of other origin servers on behalf of its clients, it may be used as a vector of attacks against other sites or services. Thus, SPARQL
        protocol services may effectively act as proxies for third-party clients. Such services <strong>may</strong> place restrictions on the resources that they retrieve or on the rate at which
        external resources can be retrieved. SPARQL protocol services <strong>may</strong> log client requests in such a way as to facilitate tracing them with regard to third-party origin servers or
        services.</p>
        <p>SPARQL protocol services <strong>may</strong> choose to detect these and other costly, or otherwise unsafe, queries, impose time or memory limits on queries, or impose other restrictions
        to reduce the service's (and other service's) vulnerability to denial-of-service attacks. They also <strong>may</strong> <a href="#query-failure">refuse to process such query
        requests</a>.</p>
        <p>SPARQL protocol services may remove, insert, and change underlying data via the update operation. To protect against malicious or destructive updates, implementations may choose not to
        implement the update operation. Alternatively, implementations may choose to use HTTP authentication mechanisms or other implementation-defined mechanisms to prevent unauthorized invocations
        of the update operation.</p>
        <p>Different IRIs may have the same appearance. Characters in different scripts may look similar (a Cyrillic "о" may appear similar to a Latin "o"). A character followed by combining
        characters may have the same visual representation as another character (LATIN SMALL LETTER E followed by COMBINING ACUTE ACCENT has the same visual representation as LATIN SMALL LETTER E
        WITH ACUTE). Users of SPARQL must take care to construct queries with IRIs that match the IRIs in the data. Further information about matching of similar characters can be found in [[[UTR36]]] 
        and [[[RFC3987]]] Section 8.</p>
      </section>
    </section>
    <section id="conformance">
      <h2>Conformance</h2>
      <p>The status of the parts of SPARQL 1.2 Protocol (this document) is as follows:</p>
      <ul>
        <li>Section 1 Introduction: <strong>normative</strong></li>
        <li>Section 2 SPARQL Protocol Operations: <strong>normative</strong></li>
        <li>Section 3: Example SPARQL Protocol Requests: <strong>informative</strong></li>
        <li>Section 4: Policy Considerations: <strong>normative</strong></li>
        <li>Section 5: Conformance: <strong>normative</strong></li>
        <li>Section 6: Changes Since Previous Recommendation: <strong>informative</strong></li>
        <li>Section A.1: Normative References: <strong>normative</strong></li>
        <li>Section A.2: Other References: <strong>informative</strong></li>
      </ul>
      <p>A <span class="doc-ref" id="conformant-sparql-protocol-service">conformant SPARQL Protocol service</span>:</p>
      <ol>
        <li><strong>must</strong> implement either the <code>query</code> operation or the <code>update</code> operation in the way described in this document ("SPARQL 1.2 Protocol");</li>
        <li><strong>may</strong> implement both the <code>query</code> and <code>update</code> operations;</li>
        <li><strong>must</strong> be consistent with the normative constraints (indicated by <a data-cite="rfc2119#">RFC2119</a> keywords [[RFC2119]]) described in <a href="#policy">4. Policy
        Considerations</a>.</li>
      </ol>
    </section>
    <section id="changes">
      <h2>Changes Since Previous Recommendation (Informative)</h2>
      <p>This specification extends and updates the <a href="http://www.w3.org/TR/2008/REC-rdf-sparql-protocol-20080115/">SPARQL Protocol for RDF of January, 2008</a>. The significant changes
      are:</p>
      <ul>
        <li>Remove the WSDL definition of the protocol in favor of an HTTP-based protocol</li>
        <li>Define an Update operation for issuing SPARQL Update requests</li>
        <li>Updated conformance criteria to accommodate the update operation</li>
        <li>Relaxed the requirements on specific HTTP response codes to allow for other codes as long as they align with HTTP semantics</li>
        <li>Added a variant of the query operation that directly posts a query string in the body of a POST request</li>
      </ul>
    </section>
    
<!-- BODY -->
    <section id="privacy">
      <h2>Privacy Considerations</h2>
      <p>TODO</p>
    </section>

    <section id="security">
      <h2>Security Considerations</h2>
      <p>TODO</p>
    </section>

    <section id="internationalization">
      <h2>Internationalization Considerations</h2>
      <p>TODO</p>                
    </section>

    <section class="appendix informative" id="changes-from-sparql11">
      <h2>Change Log</h2>
      <p>TODO</p>
    </section>   

    <section id="index"></section>

  </body>
</html>
